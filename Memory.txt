Summary: Description of memory with tiers of complexity from basic to in-depth.

=======================
Tier 1: Memory is Basic
=======================


Memory is simply a collection of bits which can be stored and accessed. A single bit can hold the value of 0 or 1. These collections of bits can be viewed in many different ways in which the order of the bits matters to the information which we may derive. In the same way that a series of letters are used to make up words, bits are interpreted in groups which many programming languages refer to as types.

=================================
Tier 1: Memory as intrinsic Types
=================================

Many CPU's tend to use a set of common interpretations of bits (memory) which a program will refer to as an intrinsic type.

List of common names for intrinsic integer (ie a number: +/-29) types (signed and unsigned) by size in bits:
8  bits - byte, char, unsigned char, signed char, u8, s8, uint8_t, int8_t                  (extra) sbyte, ubyte, schar, uchar
16 bits - short, unsigned short, signed short, u16, s16, uint16_t, int16_t                 (extra) ushort, char (unicode)
32 bits - int, long, unsigned int, signed int, u32, s32, uint32_t, int32_t                 (extra) uint, char (unicode)
64 bits - long, long long, unsigned long long, signed long long, u64, s64, uint64_t, s64_t (extra) ulong

List of common names for floating point (ie a number: +/-1.767) types by size in bits:
16 bits - (extra) half, f16
32 bits - float, single, f32
64 bits - double, f64

* The list above is incomplete and is NOT standardized across programming languages, C++'s "long" is not like C#'s "long", but most longs are 32 or 64 bits.
* (extra) A special type you may see is the size_t which is an unsigned integer type whose size is determined by the CPU the program is compiled for. For most machines, this will use by 64 bits.
* (extra) Unicode is a variable length type which is not usually understood by the CPU directly and can be 1-4 bytes long. Variable length data is a powerful tool used in many high-performance situations and in some languages warrants its own type.

When you compile a program the type will help determine the possible instructions that will be generated by the compiler. For example, if I am adding 2 unsigned integers (u32) and save the result as u32, my 2 added values, and the resulting value will always be interpreted as a non-negative number. (extra) If I were to save the result as an s32, it's possible that we can overflow and interpreted the bits incorrectly and will see a really large positive number as a negative number.



====================================
Tier 1: Memory as user defined types
====================================

Not all types within a program have a set of CPU intrinsic operations attached to them. Many programming languages allow for the creation of user-defined types that encapsulate many intrinsic types that logically work together to form a set of functionality. A string can be a user-defined type which is a collection of u8, or u16 types whereby each u8 or u16's number maps to a specific character (extra) which can be looked up in ASCII.

Example:
         u8: 01000001                  (binary) = 65       (decimal) = "A"         (ASCII)
string data: 01000001 01000010 01000101(binary) = 65 66 75 (decimal) = "A" "B" "E" (ASCII)

=================================
Tier 1: Memory Addresses/pointers
=================================

Memory is a collection of bits, and we can look at a specific location in the memory by its address value. An address does not specify a location in bits, but rather its location in bytes. An address is logically just a number that we can use to look into the memory by x number of bytes from some known start point in memory. For this reason any number both postive and negative can represent a valid address. (extra) In most cases the known start point is 0, as it is for absolute pointers, but this is not the case for relative pointers.

Example

Address Space

  byte 0   byte 1   byte 2   byte 3   byte 4   byte 5
 /      \ /      \ /      \ /      \ /      \ /      \
 01111110 10000001 10010001 01001110 01101101 01110101 ...
 \                                                   /
  \______________________Memory_____________________/



Looking at address 4 in the memory above, we see the byte "01101101".
Looking at address 0 in the memory above, we see the byte "01111110".

A pointer is basically an address location with a type which describes how to interpret that address's memory and move to other addresses of the same type which are next to it in memory. (See Pointers.txt for more details)





==============================
Tier 2: Memory must be Aligned
==============================

The smallest part of memory a CPU can address is a byte. A byte is also usually the smallest part of memory a CPU can run an operation on as well.

The CPU has memory alignment requirements for some of its operations. An operation may require 4-byte or 8-byte alignment such that it can only operate on memory address which is a multiple of 4 or 8. (ie. 4-byte alignment would require an address like 0, 4, 8, or 12 each of which is a multiple of 4)

Example

  byte 0   byte 1   byte 2   byte 3
 /      \ /      \ /      \ /      \
 01111110 10000001 11010011 01111100 ...
 \                                 /
  \____________Memory_____________/

Let's say we want to read the memory above as a u16. A CPU may require this read operation must be 2 byte aligned. This means that we would only be able to read bytes 0,1 as a u16 and bytes 2,3 as a u16. We may be unable to read byte 1,2 as a u16 as it is not 2 byte aligned!

===============================================================
Tier 2: Memory as Unions/Sum Types/Variants and pointer casting
===============================================================

Remember a programming language's type is simply an interpretation of a set number of bits in memory. A type is NOT memory, it is the interpretation we use to derive meaning from the bits of data. For this reason, we have unions/sum types/variants which allow us to view a section of memory as if it were one of many types. 

Example: memory at address 10 as u8: 10001001 (binary) =  137 (decimal)
Example: memory at address 10 as s8: 10001001 (binary) = -119 (decimal)

This is particularly helpful when you have a state whereby lots of information isn't used and by knowing this you can reduce the amount of memory used and the complexity of your code.

Example: (extra) Let's consider guard NPC in a game. The guard has 2 states "attacking" and "guarding". While attacking we hold onto data about the fight, let's say 84 bytes of information. While we are guarding we only need to patrol a set path, let's say 98 bytes of information. While guarding we are never attacking and while we are attacking we are never guarding. With this in mind, we can store the "attacking" data and the "guarding" data at the same address and use a union/Sum Type/Variant to interpret the memory according to our current state.

(extra) Going into the details, this looks dangerous/scary to use, but can in-fact reduce code complexity and bugs caused by stale data. Some programming languages will force you to initialize all of the data in the union between state changes and disallow accessing types connected into other non-active states. 

Using a union/sum type/variant can prove helpful 

==========================================
Tier 2: Memory is simple and can be mapped
==========================================

A fact I hope you understand now is that memory isn't all that special by itself. Just a collection of bits we can store and access and keep an address for every byte. How we look and operate on memory is where most of our complexity originates.

(extra) Memory is so simple it can be mapped/redirected across hardware containers (onto an SSD) and even across computers. Virtual Memory is one such space-saving technique which uses mapping/redirecting a memory address outside of RAM for infrequently access data.

(extra) You can also explicitly map/redirect memory on most operating systems allowing you an easy interface with memory stored on other devices. This is one common way you can pass information to a GPU. Basically, this redirects the memory going from the CPU to Main Memory (RAM) to instead go to the GPU's memory. (see Tier 8)


=================================
Tier 3: Memory may be constrained
=================================

Not all memory is created equal. Memory has 3 basic operations: read, write, and execute. The memory's physical hardware or software may be constrained to only allow 0 or more of the operations above. This is incredibly useful since these memory constraints will crash our program if we violate them.

(extra) When debugging a huge program, adding memory constraints can prove helpful to find the source of the heap or stack corruption. (see Memory Constraints, StackSentinal.txt)


============================================================
Tier 3: Memory storage speed heirarchy (General programming)
============================================================

This is a basic diagram of the general performance to access certain hardware containers of memory. The "|" character division indicates roughly 1 or more orders of magnitude drop in speed from the previous medium. This is a rough approximation and may be incorrect even as I write it, but the general picture of speed to access memory in an application environment.

Fastest
    CPU Registers
    |
    CPU L1 Cache
    CPU L2 Cache
    CPU L3 Cache
    |
    Random Access Memory (RAM)
    |
    GPU Memory (VRAM)
    Solid State Drive (SSD)
    |
    Hard Drives (HD)
    |
    Local Area Network (LAN)
    |
    Internet Connection
Slowest

=============
Tier 3: Files
=============

Files are chuncks of memory that normally are accessed through file descriptors. A file descriptor is the operating system's (OS)'s "pointer" like object to the filesystem's storage. Once a file is open a file descriptor also may allow you change where it points to within the file.

Common functionality in filesystems

- Open: Often takes file's path and returns a file descriptor. Open may have many other options about how to open the file, where to start reading, is the file locked to other processes, and much more depending on your OS.
- Close: Takes a file descriptor and closes it.
- Seek: Move the file descriptor's reference within the file.
- Read: Read often takes a buffer of 1-n bytes and writes to that buffer with the contents of where the file descriptor references within the file.
- Write: Write often takes a buffer of 1-n bytes and writes that buffer into the file

(extra) File Input/Output (I/O) is very slow so many filesystems allow for a blocking and non-blocking modes. In blocking mode (usually the default) the function call will wait until the operation has been completed before returning. In non-blocking mode the function may return before the operation is completed allowing our program to continue working while the file operation completes.

================================
Tier 3: Memory Mapping in the OS
================================

Most modern operating systems (OS) use memory mapping for a variety of task. Three common tasks you may find are shared memory, virtual memory, memory mapped files.

Shared memory is when two or more processes (aka applications/programs) have some virtual address space which map to the same physical address in memory. This allows all processes to access this memory simultaniously, however this may require synchronization depending on the design. Shared memory is one of the fastest Inter-Process Communication (IPC) methods and is often used for high bandwitdth simple data transfer.

Virtual memory is the process of mapping the program's address space into physical memory (RAM) or into other slower storage containers (hard drive, network drives, etc...). In general the choice to keep the memory in RAM is related to how often it is accessed and how full the RAM current is. This is great for modern OS which have many programs that most of the time do nothing, but have allocated memory. While these programs sit, the memory can be freed up for running application effectivly increasing the systems memory through software.

(extra) The OS may provide an API to control the behavior of virtual memory:
- Reserve: Reserve a block of virtual address space to map at a later time.
- Commit: Take a reserved block of virtual address space and map it directly to memory.

(extra) Virtual memory works well untill you reach the the physical RAM limit whereby you have active memory greater than your actual RAM. This causes the system to "thrash memory" spending a lot of time moving memory between storage and RAM as your programs waits for a few bytes it normaly gets near instantly.

Memory mapped files is when you map a file into RAM to quickly modify/update its contents logically in the filesystem. This maps some of the application's address space onto the filesystem's address space so that any pointers into the applications address space modify the filesystem's file directly. In general this does not do file I/O on read/write, but save parts or the whole buffer when needed.

(extra) Performance consiquences: This technique can remove a copy step when saving the file to disk. It also requires significantly less system calls which may be very slow depending on your OS. It also may be very slow depending on address resolution and how file mapping behaves on the OS and system environment.

(extra) A ram drive is basically this idea, but more integrated into filesystem and drivers.






#3
@ file cache (see windows API) Add into files section

@ most Significant bits
@ Endianness (Add to teir 2/3)


===================================
Tier 4: Performance: Cache is King!
===================================

@TODO
Memory is Slow.
Cache should only get exactly what you need
Cache pre-fetching should be reliable
@SIMD streaming instructions (Avoid the cache)

#4
@ Fork process (copy on write optimization)
@ Memory Order & Atomic operations


